<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RLWEEngine</name>
    </assembly>
    <members>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Division">
            <summary>
            Static library that provides all operations related with division and modular arithmetic to <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            <para>Some methods are provided in both mutable and immutable way.</para>
            
            <description>There are several variants provided listed below:</description>
            <list type="bullet">
            <item><description>BigInteger Division and Remainder operations</description></item>
            <item><description>Modular exponentiation between BigInteger</description></item>
            <item><description>Modular inverse of a BigInteger numbers</description>/&gt;</item>
            <item><description>BigInteger division and remainder by int</description></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Divide(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32)">
            <summary>
            Divides the array 'a' by the array 'b' and gets the quotient and the remainder.
            <para>Implements the Knuth's division algorithm. See D. Knuth, The Art of Computer Programming, 
            vol. 2. Steps D1-D8 correspond the steps in the algorithm description.</para>
            </summary>
            
            <param name="Quotient">The quotient</param>
            <param name="QuotientLen">The quotient's length</param>
            <param name="X">The dividend</param>
            <param name="XLen">The dividend's length</param>
            <param name="Y">The divisor</param>
            <param name="YLength">The divisor's length</param>
            
            <returns>eturn the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideAndRemainderByInteger(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,System.Int32)">
            <summary>
            Computes the quotient and the remainder after a division by an int number
            </summary>
            
            <param name="Value">The BigInteger dividend</param>
            <param name="Divisor">The divisor</param>
            <param name="DivisorSign">The divisors sign</param>
            
            <returns>Returns an array of the form <c>[quotient, remainder]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideArrayByInt(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division algorithm.
            <para>See D. Knuth, The Art of Computer Programming, vol. 2.</para>
            </summary>
            
            <param name="Destination">The quotient</param>
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.EvenModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be even.
            Based on theThe square and multiply algorithm and the Montgomery Reduction 
            C. K. Koc - Montgomery Reduction with Even Modulus.
            The square and multiply algorithm and the Montgomery Reduction.
            ar.org.fitc.ref "C. K. Koc - Montgomery Reduction with Even Modulus"
            </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The Exponent</param>
            <param name="Modulus">The Modulus</param>
            
            <returns><c>x1 + q * y</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Return the greatest common divisor of X and Y
            </summary>
            
            <param name="X">Operand 1, must be greater than zero</param>
            <param name="Y">Operand 2, must be greater than zero</param>
            
            <returns>Returns <c>GCD(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(System.Int64,System.Int64)">
            <summary>
            Performs the same as GcdBinary(BigInteger, BigInteger)}, but with numbers of 63 bits, 
            represented in positives values of long type.
            </summary>
            
            <param name="X">A positive number</param>
            <param name="Y">A positive number></param>
            
            <returns>Returns <c>Gcd(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.InplaceModPow2(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs <c>X = X Mod (2<sup>N</sup>)</c>
            </summary>
            <param name="X">A positive number, it will store the result</param>
            <param name="N">A positive exponent of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.ModInverseMontgomery(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Calculates x.modInverse(p) Based on: Savas, E; Koc, C "The Montgomery Modular Inverse - Revised"
            </summary>
            
            <param name="X">BigInteger X</param>
            <param name="P">BigInteger P</param>
            
            <returns>Returns <c>1/X Mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.MultiplyAndSubtract(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array by int and subtracts it from a subarray of another array
            </summary>
            
            <param name="X">The array to subtract from</param>
            <param name="Start">The start element of the subarray of X</param>
            <param name="Y">The array to be multiplied and subtracted</param>
            <param name="YLength">The length of Y</param>
            <param name="Multiplier">The multiplier of Y</param>
            
            <returns>Returns the carry element of subtraction</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.OddModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be odd. </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The exponent</param>
            <param name="Modulus">The modulus</param>
            
            <returns><c>(modulus[0]^(-1)) (mod 2^32)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Divides a BigInteger by a signed int and returns the remainder
            </summary>
            
            <param name="X">The BigInteger to be divided. Must be non-negative</param>
            <param name="Divisor">A signed integer</param>
            
            <returns>Returns Divide % Divisor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.RemainderArrayByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division
            algorithm. See D. Knuth, The Art of Computer Programming, vol. 2.
            </summary>
            
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom">
            <summary>
            <h3>An implementation of a Cryptographically Secure Pseudo Random Number Generator: SecureRandom.</h3> 
            
            <para>Uses the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class to generate non-negative random numbers.</para>
            </summary>
            
            <example>
            <c>
            int x;
            using (SecureRandom rnd = new SecureRandom())
                x = rnd.NextInt32();
            </c>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/04/28" version="1.4.0.0" author="John Underhill">Added thread safety</revision>
            </revisionHistory>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BufferSize">Size of the internal buffer; must be more than zero</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextChar">
            <summary>
            Get a random char
            </summary>
            
            <returns>Random char</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.AnyDouble">
            <summary>
            Get a non-ranged random double
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextDouble">
            <summary>
            Get a random double in the range 0.0 to 1.0
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Next">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32">
            <summary>
            Get a random unsigned 32bit integer
            </summary>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64">
            <summary>
            Get a random long integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64,System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Int32)">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Byte[])">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Data">Array to fill with pseudo random</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetChars(System.Int32)">
            <summary>
            Gets pseudo random chars
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand chars</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetByteRange(System.Int64)">
            <remarks>
            Returns the number of bytes needed to build 
            an integer existing within a byte range
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBits(System.Byte[],System.Int64)">
            <remarks>
            If you need a dice roll, use the Random class (smaller range = reduced entropy)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng">
            <summary>
            <h3>DGCPrng: An implementation of a Digest Counter based Random Number Generator.</h3>
            <para>Uses a Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new DGCPrng([Digests])
                num = rnd.Next([Minimum], [Maximum]);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">digest</see>.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">
            <summary>
            Pseudo Random Number Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digests,VTDev.Libraries.CEXEngine.Crypto.SeedGenerators,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="SeedEngine">The Seed engine used to create the salt (default is CSPRsg)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the buffer size is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Digests,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is digest blocksize + 8)</param>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the seed is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the seed or buffer size is too small; (min. seed = digest blocksize + 8)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign">
             <summary>
             An Ring-LWE One Time Sign (OTS) message sign and verify implementation
             </summary>
             
             <example>
             <description>Example of using the signing and verifying an array:</description>
             <code>
             RLWEParameters encParams = RLWEParamSets.RLWEN256Q768;
             RLWEKeyGenerator keyGen = new RLWEKeyGenerator(encParams);
             IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
             byte[] code;
             byte[] data = new byte[100];
            
             // get the message code for an array of bytes
             using (RLWESign signer = new RLWESign(encParams))
             {
                 signer.Initialize(keyPair);
                 code = signer.Sign(data, 0, data.Length);
             }
            
             // test the message for validity
             using (RLWESign signer = new RLWESign(encParams))
             {
                 signer.Initialize(keyPair);
                 bool valid = signer.Verify(data, 0, data.Length, code);
             }
             </code>
             </example>
             
             <revisionHistory>
                 <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto Digests Enumeration</seealso>
             
             <remarks>
             <description><h4>Implementation Notes:</h4></description>
             <list type="bullet">
             <item><description>Signing is intended as a one time only key implementation (OTS); keys should never be re-used.</description></item>
             <item><description>Digests can be any of the implemented digests; Blake, Keccak, SHA-2 or Skein.</description></item>
             </list>
             
             <description><h4>Code Base Guides:</h4></description>
             <list type="table">
             <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">version</see>.</description></item>
             </list> 
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The RLWE cipher used to encrypt the hash</param>
            <param name="Digest">The type of digest engine used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)">
            <summary>
            Initialize the cipher
            </summary>
            
            <param name="KeyPair">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair"/> containing the RLWE public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid key pair is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Reset">
            <summary>
            Reset the underlying digest engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream contining the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid key pair is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if input array is too short, signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if input array is too short, signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Compute(System.IO.Stream)">
            <summary>
            Compute the hash from a stream
            </summary>
            
            <param name="InputStream">The input stream</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute the hash from a byte array
            </summary>
            
            <param name="Input">The data byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Engine">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWESign.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.IntUtils">
            <summary>
            An integer utilities class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int32)">
            <summary>
            Returns the number of one-bits in the two's complement binary 
            representation of the specified int value. 
            <para>This function is sometimes referred to as the population count.</para>
            </summary>
            
            <param name="X">The value whose bits are to be counted</param>
            
            <returns>The number of one-bits in the two's complement binary representation of the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int64)">
            <summary>
            Returns the number of bits in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of bits in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.Clone(System.Int32[])">
            <summary>
            Create a copy of an array
            </summary>
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.DoubleToLong(System.Double)">
            <summary>
            Convert a double to a long value
            </summary>
            
            <param name="X">Double to convert</param>
            
            <returns>Long value representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.FloatToInt(System.Single)">
            <summary>
            Copy a floats bits to an integer
            </summary>
            
            <param name="X">Float to convert</param>
            
            <returns>The integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int32)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int64)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToBytes(System.Int32)">
            <summary>
            Copy an integer to a byte array
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The integer bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntsToBytes(System.Int32[])">
            <summary>
            Copy an array of integers to a byte array
            </summary>
            
            <param name="X">Array of integers</param>
            
            <returns>The integers bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToFloat(System.Int32)">
            <summary>
            Copy an integer bits to a float
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The float</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int32)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int64)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int32)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int64)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String)">
            <summary>
            Parses the string argument as a signed decimal integer. 
            </summary>
            
            <param name="S">A String containing the int representation to be parsed</param>
            
            <returns>The integer value represented by the argument in decimal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String,System.Int32)">
            <summary>
            Parses the string argument as a signed integer in the radix specified by the second argument. 
            </summary>
            
            <param name="S">The String containing the integer representation to be parsed</param>
            <param name="Radix">The radix to be used while parsing</param>
            
            <returns>The integer represented by the string argument in the specified radix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReadShort(System.IO.Stream)">
            <summary>
            Read a short value (16 bits) from a stream
            </summary>
            
            <param name="InputStream">Stream containing the short value</param>
            
            <returns>The Int16 value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Byte[])">
            <summary>
            Reverse a byte array order and copy to an integer
            </summary>
            
            <param name="Data">The byte array to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Int32)">
            <summary>
            Reverse the byte order of an integer
            </summary>
            
            <param name="Value">The integer value to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseInt(System.Int32)">
            <summary>
            Returns the value obtained by reversing the order of the bits in the 
            two's complement binary representation of the specified int value
            </summary>
            
            <param name="X">The value to be reversed</param>
            
            <returns>The value obtained by reversing order of the bits in the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.Signum(System.Int64)">
            <summary>
            Returns the signum function of the specified long value. 
            <para>The return value is -1 if the specified value is negative;
            0 if the specified value is zero; and 1 if the specified value is positive.</para>
            </summary>
            
            <param name="X">The value whose signum is to be computed</param>
            
            <returns>The signum function of the specified long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int32)">
            <summary>
            Convert an integer to a string
            </summary>
            
            <param name="X">The integer to convert</param>
            <returns>Returns the integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int64)">
            <summary>
            Convert a long integer to a string
            </summary>
            
            <param name="X">The long integer to convert</param>
            <returns>Returns the long integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int32">int</see> representing the shifted number.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int64,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int64">long integer</see> representing the shifted number.
            </returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">
            <summary>
            The libraries base exception type
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.RLWEException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.RLWEException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.RLWEException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Exceptions.RLWEException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Exceptions.RLWEException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024">
            <summary>
            <h3>Keccak1024: An implementation of the SHA-3 Keccak digest.</h3>
            <h4>Note: Experimental! may need future adjustments</h4>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 128 and 96 bytes (1024, 768 bits).</description></item>
            <item><description>Block sizes are 40, and 54 bytes (288, 320 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">
            <summary>
            Hash Digest Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM">
            <summary>
            <h3>TSM: An implementation based on the Twofish and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>TSM is Twofish<cite>Twofish</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 24, and 32, default is 16.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the rounds functions, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a round of Serpent.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in TSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            TSM is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher">
            <summary>
            Block Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey">
            <summary>
            A Ring-LWE public key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">
            <summary>
            The Asymmetric key interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.#ctor(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The number of coefficients</param>
            <param name="A">The polynomial 'a'</param>
            <param name="P">The polynomial 'p'</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array.
            <para>The array can contain only the public key.</para>
            </summary>
            
            <param name="KeyArray">The byte array containing the key</param>
            
            <returns>An initialized RLWEPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a byte array.
            <para>The stream can contain only the public key.</para>
            </summary>
            
            <param name="KeyStream">The byte array containing the key</param>
            
            <returns>An initialized RLWEPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>KeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.Clone">
            <summary>
            Create a copy of this RLWEPublicKey instance
            </summary>
            
            <returns>RLWEPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.A">
            <summary>
            Get: Returns the A array
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.N">
            <summary>
            Get: Returns the number of coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey.P">
            <summary>
            Get: Returns the P array
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.HexConverter">
            <summary>
            A Hexadecimal conversion helper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.ToString(System.Byte[])">
            <summary>
            Convert an array into a hex string
            </summary>
            
            <param name="Data">Data to convert</param>
            
            <returns>Data as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode an array of bytes in hexadecimal format
            </summary>
            
            <param name="Data">The bytes to encode</param>
            <param name="Offset">The starting offset within the Data array</param>
            <param name="Length">The number of bytes to encode</param>
            
            <returns>Encode bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Decode(System.String)">
            <summary>
            Decode a Hex encoded string and return the output
            </summary>
            
            <param name="Data">Hex string</param>
            
            <returns>Decoded bytes</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Multiplication">
            <summary>
            Static library that provides all multiplication of BigInteger methods
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigTenPows">
            <summary>
            An array with the first powers of ten in BigInteger version: 10^0,10^1,...,10^31)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigFivePows">
            <summary>
            An array with the first powers of five in {@code BigInteger} version: (5^0,5^1,...,5^31)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs a multiplication of two BigInteger and hides the algorithm used
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Y">A positive exponent</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyArraysPAP(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[])">
            <summary>
            Multiply a member of array X with array Y
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="XLength">Length of X array to process</param>
            <param name="Y">A positive exponent</param>
            <param name="YLength">Length of Y array to process</param>
            <param name="ResDigits">The result</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array of integers by an integer value
            </summary>
            
            <param name="X">The array of integers</param>
            <param name="Size">The number of elements of intArray to be multiplied</param>
            <param name="Factor">The multiplier</param>
            
            <returns>The top digit of production</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByFivePow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a power of five.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive int exponent</param>
            
            <returns>X * 5 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByPositiveInt(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a positive integer.
            </summary>
            
            <param name="X">An arbitrary BigInteger</param>
            <param name="Factor">A positive int number</param>
            
            <returns>X * Factor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByTenPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int64)">
            <summary>
            Multiplies a number by a power of ten.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive long exponent</param>
            
            <returns>X * 10 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Pow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.PowerOf10(System.Int64)">
            <summary>
            It calculates a power of ten, which exponent could be out of 32-bit range.
            <para>Note that internally this method will be used in the worst case with
            an exponent equals to: Integer.Max - Integer.Min.</para>
            </summary>
            
            <param name="Exponent">The exponent of power of ten, it must be positive</param>
            
            <returns>BigInteger with value 10<sup>exp</sup>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.UnsignedMultAddAdd(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the value unsigned ((uint)a*(uint)b + (uint)c + (uint)d).
            <para>This method could improve the readability and performance of the code.</para>
            </summary>
            
            <param name="A">Operand 1</param>
            <param name="B">Operand 2</param>
            <param name="C">Operand 3</param>
            <param name="D">Operand 4</param>
            <returns></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg">
            <summary>
            Generates seed material for a CSPrng using various processed system counters passed through an XorShift+ generator
            <para>An original construct (experimental) meant to provide an alternative to the RNGCryptoServiceProvider as a source of pseudo random seeding material.</para>
            </summary>
            
            
            <example>
            <description>Example of getting a seed value:</description>
            <code>
            byte[] seed;
            using (XSPRsg rnd = new XSPRsg())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto Prng Classes</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The seed generator uses system counters and state information, that are pre-processed via modular arithmetic, 
            converted to a byte array, and then processed with an XorShift+ random generator.</para>
            
            <description>XSPGenerator uses the following state values as initial entropy sources:</description>
            <list type="bullet">
            <item><description>Network: Combined interface values for the BytesSent, UnicastPacketsSent, NonUnicastPacketsSent, BytesReceived, UnicastPacketsReceived and NonUnicastPacketsReceived values.</description></item>
            <item><description>Current Process: Handle, StartTime ticks, PeakWorkingSet64, NonpagedSystemMemorySize64, PagedSystemMemorySize64, HandleCount, and Id.</description></item>
            <item><description>Combined running processes and threads: WorkingSet64, VirtualMemorySize64, StartAddress, Id, and CurrentPriority.</description></item>
            <item><description>Environment: Ticks since startup, the Time in Ticks.</description></item>
            <item><description>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed">
            <summary>
            The Seed Generator interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Initialize">
            <summary>
            Re-initializes the generator with new state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayUtils">
            <summary>
            Extended array methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Byte[]@,System.Byte,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int64[]@,System.Int64,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Byte[]@,System.Byte[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int32[]@,System.Int32[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int64[]@,System.Int64[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Byte[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int16[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt16[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.CreateJagged``1(System.Int32[])">
            <summary>
            Create and initialize a jagged array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>Initialized jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.InitializeJagged(System.Type,System.Int32,System.Int32[])">
            <summary>
            Initialize a jagged array
            </summary>
            
            <param name="Type">Type of array</param>
            <param name="Index">The first row index of the array outer array</param>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>The initialized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Byte[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int32[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int64[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int64[]@,System.Int64,System.Int64)">
            <summary>
            Remove an element from the array
            </summary>
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Byte[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.SByte[])">
            <summary>
            Copy an sbyte array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Sbyte array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int16[])">
            <summary>
            Copy an int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt16[])">
            <summary>
            Copy an int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int32[])">
            <summary>
            Copy an int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt32[])">
            <summary>
            Copy an uint array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Uint array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int64[])">
            <summary>
            Copy an long array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Long array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.String)">
            <summary>
            Copy a string to an ASCII byte array
            </summary>
            
            <param name="Value">String to copy</param>
            
            <returns>The byte array representation</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng">
            <summary>
            <h3>An implementation of a passphrase based PKCS#5 random number generator.</h3>
            <para>Implements PKCS#5 as defined in RFC 2898</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new PBPRng(new SHA512(), PassPhrase, Salt))
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.2.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Creates a new PassphrasePrng from a passphrase and salt,
            and seeds it with the output of PKCS5
            </summary>
            
            <param name="Digest">Digest engine</param>
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">The salt value</param>
            <param name="Iterations">The number of transformation iterations performed by the digest with PKCS5 (default is 10,000)</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose"/> on this class is called (default is true)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.CreateBranch(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Creates a new Passphrase rng whose output differs but is a
            function of this rng's internal state.
            </summary>
            
            <param name="Digest">The digest instance</param>
            
            <returns>Returns a PassphrasePrng instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512">
            <summary>
            <h3>Keccak512: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 48 and 64 bytes (384 and 512 bits).</description></item>
            <item><description>Block sizes are 104, and 72 bytes (832, 576 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM">
            <summary>
            <h3>RSM: An implementation based on the Rijndael and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>RSM is the Rijndael<cite>Rijndael</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds assignments are 10, 18, 26, 34 and 42, default is 18.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the Transform functions rounds loop, a round of Serpent is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and a cipher 
            that is very resistant to differential cryptanalysis.</para>
            
            <para>The key schedule in RSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RSM is capable of processing up to 42 rounds, that is three times the number of rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> property contains available sizes</param>
            <param name="Block">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size or invalid rounds count are chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LinearTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.InverseTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the inverse of the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets">
            <summary>
            Contains sets of predefined Ring-LWE parameters
            <para>Use the FromId(byte[]) or FromName(RLWEParamSets) to return a deep copy of a parameter set</para>
            </summary>
            
            <remarks>
            <description><h4>Ring-LWE Parameter Description:</h4></description>
            <list type="table">
            <item><description>N - The number of coefficients.</description></item>
            <item><description>Q - The Q modulus.</description></item>
            <item><description>Sigma - The Sigma value.</description></item>
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>MFP - The number of random bytes to prepend to the message.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 3 byte parameter set identity code</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid or unknown OId is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid or unknown OId is used.</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEN256Q7681">
            <summary>
            Low security; uses CSPRng as the default Prng.
            <para>Security:128, MaxText:32, N:256 Q:7681, S:11.31, PublicKey Size:1036, PrivateKey Size:520</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEN512Q12289">
            <summary>
            High security; uses CSPRng as the default Prng.
            <para>Security:256, MaxText:64, N:512 Q:12289, S:12.18, PublicKey Size:2060, PrivateKey Size:1032</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEParamNames">
            <summary>
            Set id is defined as: N: coefficients, Q: Modulus
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEParamNames.N256Q7681">
            <summary>
            Low security; uses CSPRng as the default Prng.
            <para>Security:128, MaxText:32, N:256 Q:7681, S:11.31, PublicKey Size:1036, PrivateKey Size:520:</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets.RLWEParamNames.N512Q12289">
            <summary>
            High security; uses CSPRng as the default Prng.
            <para>Security:256, MaxText:64, N:512 Q:12289, S:12.18, PublicKey Size:2060, PrivateKey Size:1032</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters">
            <summary>
            The Asymmetric parameters interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToBytes">
            <summary>
            Returns the current parameter set as an ordered byte array
            </summary>
            
            <returns>Parameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToStream">
            <summary>
            Returns the current parameter set as a MemoryStream
            </summary>
            
            <returns>Parameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; array must be initialized and of sufficient length</param>
            <param name="Offset">The starting position within the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the parameter set to an output stream
            </summary>
            
            <param name="Output">Output stream</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Elementary">
            <summary>
            Static library that provides the basic arithmetic mutable operations for BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Addition</description></item>
            <item><description>Subtraction</description></item>
            <item><description>Comparison</description>/></item>
            </list>
            
            <para>In addition to this, some Inplace (mutable) methods are provided.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#add(BigInteger)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompareArrays(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Compares two arrays. All elements are treated as unsigned integers. 
            <para>The magnitude is the bit chain of elements in big-endian order.</para>
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            <param name="Size">Size the size of arrays</param>
            
            <returns>Returns 1 if A > B, -1 if A &lt; B, 0 if A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceAdd(BigInteger, BigInteger), but without the restriction of non-positive values
            </summary>
            
            <param name="A">The operand</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceSubtract(BigInteger, BigInteger), but without the restriction of non-positive values
            <para>Op1 should have enough space to save the result</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 += Op2.
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()). 
            Both should be positive (i.e. Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Adds an integer value to the array of integers remembering carry
            </summary>
            
            <param name="A">The input minuend</param>
            <param name="ASize">The minuend size</param>
            <param name="Addend">The addend</param>
            
            <returns>A possible generated carry (0 or 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs: Op1 += Addend. 
            <para>The number must have a place to hold a possible carry.</para>
            </summary>
            
            <param name="A">The operand</param>
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 -= Op2. 
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()).
            Both should be positive (what implies that Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#subtract(BigInteger)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigEndian">
            <summary>
            This is a utility class containing data type conversions using big-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string according to IEEE 1363, Section 5.5.3. Length checking is performed
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Length">The desired length of the octet string</param>
            
            <returns>Returns an octet string of length <c>OctLength</c> representing the integer <c>X</c>, or <c>null</c> if the integer is negative</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he integer to convert</param>
            
            <returns>The converted long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string of the specified length according to IEEE 1363, Section 5.5.3.
            <para>No length checking is performed (i.e., if the integer cannot be encoded into <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            <param name="InOffset">The offset in the input byte array where the octet string starts</param>
            <param name="Length">The length of the encoded integer</param>
            
            <returns>Returns an integer representing the octet string <c>bytes</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[])">
            <summary>
            Convert an int array into a byte array
            </summary>
            
            <param name="Input">The int array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array into a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded into <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array into an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyPair">
            <summary>
            An Ring-LWE Key-Pair container
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">
            <summary>
            Asymmetric key pair interface
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PublicKey">
            <summary>
            The Public key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PrivateKey">
            <summary>
            The Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="PrivateKey">The corresponding private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if an invalid key is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyPair.PublicKey">
            <summary>
            Get: Returns the public key parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyPair.PrivateKey">
            <summary>
            Get: Returns the private key parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.RoundingModes">
            <summary>
            MathContext RoundingModes used by BigInteger and BigDecimal
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Up">
            <summary>
            Rounding mode where positive values are rounded towards positive infinity
            and negative values towards negative infinity.
            <para>Rule: <c>x.Round().Abs() >= x.Abs()</c></para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Down">
            <summary>
            Rounding mode where the values are rounded towards zero.
            <para>Rule: x.Round().Abs() &lt;= x.Abs()</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Ceiling">
            <summary>
            Rounding mode to round towards positive infinity.
            <para>For positive values this rounding mode behaves as Up, for negative values as Down.
            Rule: x.Round() >= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Floor">
            <summary>
            Rounding mode to round towards negative infinity.
            <para>For positive values this rounding mode behaves as Down, for negative values as Up.
            Rule: x.Round() &lt;= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfUp">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding up.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfDown">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding down.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfEven">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding to the even neighbor.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Unnecessary">
            <summary>
            Rounding mode where the rounding operations throws an ArithmeticException for 
            the case that rounding is necessary, i.e. for the case that the value cannot be represented exactly.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX">
            <summary>
            <h3>SPX: An extended implementation of the Serpent encryption cipher.</h3>
            <para>SPX is an implementation of the Serpent<cite>Serpent</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SPX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, and 64, default is 32.</description></item>
            </list>
            
            <para>The Key Schedule has been written so that it can both accept a larger key size of 512 bits, 
            and produce the required number of working keys with a variable number of diffusion rounds.</para>
            
            <para>The diffusion rounds, (the portion of the cipher that does the actual mixing of plaintext into ciphertext),
            is exactly the same with every key length, only it can now process an increased number of rounds, from 32; 
            the standard, up to 64 rounds. 
            This increase in the ciphers diffusion cycles makes linear and differential analysis more difficult, 
            and the larger key size ensures that it can not be brute forced.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes">
            <summary>
            Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT512.#ctor(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Rand">The secure random number generator instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT512.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey,System.Byte[])">
            <summary>
            Decrypt a ciphertext
            </summary>
            
            <param name="PrivateKey">The RLWE private key</param>
            <param name="Message">The encrypted message</param>
            
            <returns>The decrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT512.Encrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey,System.Byte[])">
            <summary>
            Encrypt a message
            </summary>
            
            <param name="PublicKey">The RLWE public key</param>
            <param name="Message">The message array to encrypt</param>
            
            <returns>The encrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT512.Generate">
            <summary>
            Generate a RLWE key pair
            </summary>
            
            <returns>An initialized RLWE KeyPair</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BitLevel">
            <summary>
            Static library that provides all the bit level operations for BigInteger. 
            
            <description>The operations are:</description>
            <list type="number">
            <item><description>Left Shifting</description></item>
            <item><description>Right Shifting</description></item>
            <item><description>Bit Clearing</description></item>
            <item><description>Bit Setting</description></item>
            <item><description>Bit Counting</description></item>
            <item><description>Bit Testing</description></item>
            <item><description>Getting of the lowest bit set</description></item>
            </list>
            
            <para>All operations are provided in immutable way, and some in both mutable and immutable.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitCount(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitLength(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.FlipBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation 
            as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs val &lt;= count, val should have enough place (and one digit more)
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs Value >>= count where Value is a positive number.
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.NonZeroDroppedBits(System.Int32,System.Int32[])">
            <summary>
            Check if there are 1s in the lowest bits of this BigInteger
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Abstractly shifts left an array of integers in little endian (i.e. shift it right).
            Total shift distance in bits is intCount * 32 + count
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">The number of bits to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Value">The source BigIntger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="ValueLen">The value length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Result">The result</param>
            <param name="ResultLen">The result length</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.TestBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024">
            <summary>
            <h3>Skein1024: An implementation of the Skein digest with a 1024 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 128 bytes, (1024 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigValue">
            <summary>
            The post-chain configuration value ToDo: change these and threefish cipher to int type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256">
            <summary>
            <h3>Keccak256: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 28, 32, and 36 bytes (224, 256, and 288 bits).</description></item>
            <item><description>Block sizes are 144, 128, and 136 bytes (1152, 1024, 1088 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters">
            <summary>
            Creates, reads and writes parameter settings for RLWEEncrypt.
            <para>Predefined parameter sets are available through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParamSets"/> class</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (RLWEParameters mp = new RLWEParameters(512, 12289, 12.18, new byte[] { 2, 5, 1 }))
               mp.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">VTDev.Libraries.CEXEngine.Crypto.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>RLWE Parameter Description:</h4></description>
            <list type="table">
            <item><description>N - The number of coefficients.</description></item>
            <item><description>Q - The Q modulus.</description></item>
            <item><description>Sigma - The Sigma value.</description></item>
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>MFP - The number of random bytes to prepend to the message.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">version</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.DEFAULT_MFP">
            <summary>
            The default prepended message padding length
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.DEFAULT_N">
            <summary>
            The default number of coefficients
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.DEFAULT_Q">
            <summary>
            The default modulus
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.DEFAULT_SIGMA">
            <summary>
            The default sigma value
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Prngs)">
            <summary>
            Set the default parameters (N:512, Q:12289, Sigma:12.18)
            </summary>
            
            <param name="OId">Three bytes that uniquely identify the parameter set</param>
            <param name="Engine">The PRNG engine used to power SecureRandom</param>
            
            <exception cref="T:System.ArgumentException">Thrown if <c>N</c> or <c>Q</c> are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.#ctor(System.Int32,System.Int32,System.Double,System.Byte[],System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prngs)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The number of coefficients</param>
            <param name="Q">The Q modulus</param>
            <param name="Sigma">The Sigma value</param>
            <param name="OId">Three bytes that uniquely identify the parameter set</param>
            <param name="MFP">The number of random bytes to prepend to the message</param>
            <param name="Engine">The PRNG engine used to power SecureRandom</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if <c>N</c> or <c>Q</c> are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array.
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized RLWEParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.From(System.IO.Stream)">
            <summary>
            Read a Parameters file from a byte array.
            </summary>
            
            <param name="ParamStream">The byte array containing the params</param>
            
            <returns>An initialized RLWEParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.ToBytes">
            <summary>
            Returns the current parameter set as an ordered byte array
            </summary>
            
            <returns>RLWEParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.ToStream">
            <summary>
            Returns the current parameter set as a MemoryStream
            </summary>
            
            <returns>RLWEParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">RLWEParameters as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">RLWEParameters as a byte array; array must be initialized and of sufficient length</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the parameter set to an output stream
            </summary>
            
            <param name="Output">Output stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Clone">
            <summary>
            Create a copy of this RLWEParameters instance
            </summary>
            
            <returns>RLWEParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.OId">
            <summary>
            Get: Three bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.MFP">
            <summary>
            The number of random bytes to prepend to the message
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.N">
            <summary>
            Returns the number of coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Q">
            <summary>
            Return the modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.RandomEngine">
            <summary>
            The random engine used by SecureRandom
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters.Sigma">
            <summary>
            Returns the sigma value
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayEx">
            <summary>
            Array type extensions
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddAt``1(System.Int32[],System.Int32,``0)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Index">The insertion point within the source array</param>
            <param name="Value">The new value</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddRange``1(``0[],``0[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Deserialize``1(System.Byte[])">
            <summary>
            Convert a byte array to a class objct
            </summary>
            
            <typeparam name="T">Return object type</typeparam>
            <param name="Data">The byte array containing the class</param>
            
            <returns>The class object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOf``1(``0[],System.Int32)">
            <summary>
            Create a copy of an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array source</param>
            <param name="Length">Number of elements to copy</param>
            
            <returns>A copy of the source array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOfRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Create a ranged copy of a byte array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Byte source array</param>
            <param name="From">First element to copy</param>
            <param name="To">Last element to copy</param>
            
            <returns>Byte array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[0:,0:],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveAt``1(``0[],System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
            
            /// <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Serialize(System.Object)">
            <summary>
            Serialize an object to a byte array
            </summary>
            
            <param name="Obj">The object to serialize</param>
            
            <returns>The object as a serialized byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[])">
            <summary>
            Shuffle an array using the SecureRandom class
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The list instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[],VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Shuffle an array with a specific Prng class
            </summary>
            
            <typeparam name="T">Type of list</typeparam>
            <param name="Source">The list instance</param>
            <param name="Rng">The pseudo random generator</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Return a sub array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The starting position within the source array</param>
            <param name="Count">The number of bytes to copy</param>
            
            <returns>The sub array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Primality">
            <summary>
            Provides primality probabilistic methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            It uses the sieve of Eratosthenes to discard several composite numbers in 
            some appropriate range (at the moment [this, this + 1024]).
            <para>After this process it applies the Miller-Rabin test to the numbers that were not discarded in the sieve.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.ConsBigInteger(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            A random number is generated until a probable prime number is found
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.IsProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="X">BigInteger to test</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg">
            <summary>
            <h3>An implementation of a Cryptographically Secure seed generator using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random byte generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            byte seed;
            using (ISeed rnd = new CSPRng())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.GetSeed(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng">
            <summary>
            <h3>CTRPrng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new CTRPrng([BlockCiphers], [SeedGenerators]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Seed">VTDev.Libraries.CEXEngine.Crypto.Seed ISeed Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers">VTDev.Libraries.CEXEngine.Crypto.BlockCiphers Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers">cipher</see>.</description></item>
            <item><description>Parallelized by default on a multi processer system when an input byte array of <see cref="!:ParallelMinimumSize"/> bytes or larger is used.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.BlockCiphers,VTDev.Libraries.CEXEngine.Crypto.SeedGenerators,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.BlockCiphers,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + counter 16)</param>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the seed is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the seed is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams">
            <summary>
            A Cipher Key and Vector Container class.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key
            </summary>
            
            <param name="Key">Cipher Key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key and IV.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key, IV, and IKM.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
            <param name="IKM">IKM value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.IKM">
            <summary>
            Input Key Material
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Key">
            <summary>
            Cipher Key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.IV">
            <summary>
            Cipher Initialization Vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512">
            <summary>
            <h3>Skein512: An implementation of the Skein digest with a 512 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> to reinitialize.</description></item>
            </list> 
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigString">
            <summary>
            The configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512">
            <summary>
            <h3>SHA512: An implementation of the SHA-2 digest with a 512 bit digest return size.</h3>
            <para>The SHA-2<cite>Fips 180-4</cite> 512 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [64 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 64 bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512">
            <summary>
            <h3>Blake512: An implementation of the Blake digest with a 512 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG">
            <summary>
            <h3>An implementation of the Cubic Congruential Generator II random number generator: CCG</h3>
            <para>Implements CCG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.4</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CCG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">CubicResiduePrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be initialized.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC">
            <summary>
            <h3>SHA256 Hash based Message Authentication Code Wrapper using SHA-2 256.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 32 bytes, (256 bits).</description></item>
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA256HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">
            <summary>
            Message Authentication Code (MAC) Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">MAC key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the hash buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class. 
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockSize">
            <summary>
            Get: The Ciphers internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers">
            <summary>
            Block Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockCiphers.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digests">
            <summary>
            Message Digests
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Blake256">
            <summary>
            The Blake digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Blake512">
            <summary>
            The Blake digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Keccak256">
            <summary>
            The SHA-3 digest based on Keccak with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Keccak512">
            <summary>
            The SHA-3 digest based on Keccak with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Keccak1024">
            <summary>
            The SHA-3 digest based on Keccak with a 1024 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.SHA256">
             <summary>
            The SHA-2 digest with a 256 bit return size
             </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.SHA512">
            <summary>
            The SHA-2 digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein256">
            <summary>
            The Skein digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein512">
            <summary>
            The Skein digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein1024">
            <summary>
            The Skein digest with a 1024 bit return size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generators">
            <summary>
            Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.CTRDrbg">
            <summary>
            An implementation of a Encryption Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.DGCDrbg">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.KDF2Drbg">
            <summary>
            An implementation of a Hash based Key Derivation Function PBKDF2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.PKCS5">
            <summary>
            An implementation of a Hash based Key Derivation PKCS#5 Version 2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.SP20Drbg">
            <summary>
            An implementation of a Salsa20 Counter based DRBG
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">
            <summary>
            Pseudo Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.BBSG">
            <summary>
            A Blum-Blum-Shub random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.CCG">
            <summary>
            A Cubic Congruential Generator II (CCG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.CSPRng">
            <summary>
             A Secure PRNG using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.CTRPrng">
            <summary>
            A Symmetric Cipher Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.DGCPrng">
            <summary>
            A Digest Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.MODEXPG">
            <summary>
            A Modular Exponentiation Generator (MODEXPG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.PBPrng">
            <summary>
            An implementation of a passphrase based PKCS#5 random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.QCG1">
            <summary>
            A Quadratic Congruential Generator I (QCG-I) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.QCG2">
            <summary>
            A Quadratic Congruential Generator II (QCG-II) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.SP20Prng">
            <summary>
            An implementation of a Salsa20 Counter based Prng
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.SeedGenerators">
            <summary>
            Seed Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.SeedGenerators.CSPRsg">
            <summary>
            A Secure Seed Generator using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.SeedGenerators.XSPRsg">
            <summary>
            A Secure Seed Generator using an Xor+ generator
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg" -->
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator">
            <summary>
            Random Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Hash function</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Info value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Three state Seed paramater: 
            If Seed size is equal to digest blocksize plus counter size, both are updated. 
            If Seed size is equal to digest block size, internal state seed is updated.
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Seed does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT256.#ctor(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="SecRand">The secure random number generator instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT256.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey,System.Byte[])">
            <summary>
            Decrypt a ciphertext
            </summary>
            
            <param name="PrivateKey">The RLWE private key</param>
            <param name="Message">The encrypted message</param>
            
            <returns>The decrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT256.Encrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey,System.Byte[])">
            <summary>
            Encrypt a message
            </summary>
            
            <param name="PublicKey">The RLWE public key</param>
            <param name="Message">The message array to encrypt</param>
            
            <returns>The encrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.Arithmetic.NTT256.Generate">
            <summary>
            Generate a RLWE key pair
            </summary>
            
            <returns>An initialized RLWE KeyPair</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Conversion">
            <summary>
            Static library that provides BigInteger base conversion from/to any integer represented in an String Object
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2Double(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>Returns a BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            The double representation has a mantissa of length 53. For example, 2^53+1 = 9007199254740993 is returned as double 9007199254740992.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2String(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(System.Int64,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX">
            <summary>
            <h3>RSX: An extended implementation of the Rijndael encryption cipher, using a Serpent key expansion routine.</h3>
            <para>Deprecated: removed by 1.4</para>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/12" version="1.1.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalBlockSizes"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.SerpentKey(System.Byte[])">
            <remarks>
            Expand key material into a session key.
            Uses an adjusted version of Serpents key scheduler with 
            an extended polynominal primitive, and rounds adjusted for Rijndael.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb1(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb2(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb3(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb4(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb5(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb6(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb7(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Dispose(System.Boolean)">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">
            <summary>
            The Asymmetric cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)">
            <summary>
            Initialize the cipher
            </summary>
            
            <param name="Encryption">When true cipher is for encryption, if false, decryption</param>
            <param name="KeyPair">The public and private key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.MaxCipherText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Alloc(System.UInt32)">
            <summary>
            Allocate heap memory
            </summary>
            
            <param name="Size">size desired</param>
            
            <returns>memory address</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Compare(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Compare two arrays for equality
            </summary>
            
            <param name="X">The first array</param>
            <param name="Y">The second array</param>
            <param name="Length">The number of bytes to compare</param>
            
            <returns>The number of bytes that match</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Copy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Copy a source array to a destination array
            </summary>
            
            <param name="Destination">The pointer to the destination array</param>
            <param name="Source">The pointer to the source array</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Fill(System.IntPtr,System.Int32,System.Byte)">
            <summary>
            Fill an array with a value
            </summary>
            
            <param name="Destination">The pointer to the destination array</param>
            <param name="Length">The number of bytes to write</param>
            <param name="Value">The byte value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Free(System.IntPtr)">
            <summary>
            Release heap memory
            </summary>
            
            <param name="Address">memory address</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.HeapAddress">
            <summary>
            Get the pointer to the process heap
            </summary>
            
            <returns>The process heap pointer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.Move(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Copy a source array to a destination array; supports overlapping memory blocks
            </summary>
            
            <param name="Destination">The pointer to the destination array</param>
            <param name="Source">The pointer to the source array</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.MemoryUtils.ZeroMemory(System.IntPtr,System.Int32)">
            <summary>
            Zero the bytes in an array
            </summary>
            <param name="Destination">The pointer to the destination array</param>
            <param name="Length">The number of bytes to write</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compare">
            <summary>
            Compare arrays for equality
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.False(System.Boolean)">
            <summary>
            Returns true if condition is false
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.True(System.Boolean)">
            <summary>
            Returns true if condition is true
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal[],VTDev.Libraries.CEXEngine.Numeric.BigDecimal[])">
            <summary>
            Compare BigDecimal Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Compare BigInteger Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Char[],System.Char[])">
            <summary>
            Compare Char Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int16[],System.Int16[])">
            <summary>
            Compare short integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.UInt32[],System.UInt32[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int64[],System.Int64[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.UInt64[],System.UInt64[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Single[],System.Single[])">
            <summary>
            Compare float Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Double[],System.Double[])">
            <summary>
            Compare double Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual``1(``0[][],``0[][])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            <h3>This class represents immutable integer numbers of arbitrary length</h3>
            
            <description>Immutable arbitrary-precision integers.</description>
            <para>All operations behave as if BigIntegers were represented in two's-complement notation.  
            BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.</para>
            </summary>
            
            <example>
            <description>Creating a random prime example:</description>
            <code>
            BigInteger p = BigInteger.ProbablePrime(BitLength, new SecureRandom());
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.2.0">Updated and expanded the implementation</revision>
            </revisionHistory>
            
            <remarks>
            <para>Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification.
            For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder.
            All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation.</para>
            
            <para>Semantics of shift operations allow for negative shift distances.  
            A right-shift with a negative shift distance results in a left shift, and vice-versa.</para>
            
            <para>The binary operators (<c>And</c>, <c>Or</c>, <c>Xor</c>) implicitly perform sign extension on the shorter of the two operands prior to performing the operation.</para>
            
            <para>Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses.  
            These methods always return a non-negative result, between <c>0</c> and <c>(Modulus - 1)</c>, inclusive.</para>
            
            <para>Bit operations operate on a single bit of the two's-complement representation of their operand.  
            If necessary, the operand is sign-extended so that it contains the designated bit.  
            None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, 
            and the "infinite word size" abstraction provided by this class ensures that there are infinitely many "virtual sign bits" preceding each BigInteger.</para>
            <para>Large numbers are typically used in security applications and therefore BigIntegers offer dedicated functionality like the generation of large 
            prime numbers or the computation of modular inverse.</para>
            <para>Since the class was modeled to offer all the functionality as the Integer class does, it provides even methods that operate bitwise 
            on a two's complement representation of large integers. 
            Note however that the implementations favors an internal representation where magnitude and sign are treated separately. 
            Hence such operations are inefficient and should be discouraged. 
            In simple words: Do NOT implement any bit fields based on BigInteger.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Zero">
            <summary>
            The BigInteger constant 0
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.One">
            <summary>
            The BigInteger constant 1
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Ten">
            <summary>
            The BigInteger constant 10
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Byte[])">
            <summary>
            Constructs a new BigInteger from the given two's complement representation.
            <para>The most significant byte is the entry at index 0.
            The most significant bit of this entry determines the sign of the new BigInteger instance.
            The given array must not be empty.</para>
            </summary>
            
            <param name="Value">Two's complement representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Byte[])">
            <summary>
            Constructs a new BigInteger instance with the given sign and the given magnitude.
            <para>The sign is given as an integer (-1 for negative, 0 for zero, 1 for positive).
            The magnitude is specified as a byte array. The most significant byte is the entry at index 0.</para>
            </summary>
            
            <param name="Signum">Sign of the new BigInteger (-1 for negative, 0 for zero, 1 for positive)</param>
            <param name="Magnitude">Magnitude of the new BigInteger with the most significant byte first</param>
            
            <exception cref="T:System.FormatException">Thrown if an invalid Signum or Magnitude is passed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random non-negative BigInteger instance in the range [0, 2^(numBits)-1]
            </summary>
            
            <param name="NumBits">Maximum length of the new BigInteger in bits</param>
            <param name="Rnd">An optional random generator to be used</param>
            
            <exception cref="T:System.ArgumentException">Thrown  if NumBits &gt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random BigInteger instance in the range [0, 2^(bitLength)-1] which is probably prime. 
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^certainty).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            <param name="Rnd">An optional random generator to be used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String)">
            <summary>
            Constructs a new BigInteger instance from the string representation. 
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of decimal digits.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new BigInteger instance from the string representation.
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of digits in the specified radix.
            For the conversion the method CharHelper.Digit(char, radix) is used.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
            <param name="Radix">The base to be used for the conversion</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32[])">
            <summary>
            Creates a new BigInteger with the given sign and magnitude.
            <para>This constructor does not create a copy, so any changes to the reference will affect the new number.</para>
            </summary>
            
            <param name="Signum">The sign of the number represented by digits</param>
            <param name="Digits">The magnitude of the number</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a number which array is of size 1
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The only one digit of array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int64)">
            <summary>
            Creates a new BigInteger whose value is equal to the specified long
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The value of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Constructs a number without to create new space.
            <para>This construct should be used only if the three fields of representation are known.</para>
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="NumberLength">The length of the internal array</param>
            <param name="Digits">A reference of some array created before</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Abs">
            <summary>
            Returns a (new) BigInteger whose value is the absolute value of this
            </summary>
            
            <returns><c>Abs(this)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this + val</c>
            </summary>
            
            <param name="Augend">Value to be added to this</param>
            
            <returns><c>this + val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="Value">The value to be and'ed with the current.</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>this &amp; Value</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be not'ed and then and'ed with this</param>
            
            <returns><c>this &amp; ~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ClearBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N cleared.
            <para>The result is equivalent to this <c>&amp; ~(2^n)</c>.
            </para>
            </summary>
            
            <param name="N">Position where the bit in this has to be cleared</param>
            
            <returns><c>this &amp; ~(2^n)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compares this BigInteger with Value.
            <para>Returns one of the three values 1, 0, or -1.</para>
            </summary>
            
            <param name="Value">Value to be compared with this</param>
            
            <returns>Returns 1 if this > Value, -1 if this &lt; Value, 0 if this == Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Divide(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this / Divisor</c>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>this / Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger array which contains <c>this / Divisor</c> at index 0 and <c>this % Divisor</c> at index 1
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>[this / Divisor, this % Divisor]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.FlipBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Gcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is greatest common divisor of this and Value.
            <para>If this==0 and Value==0 then zero is returned, otherwise the result is positive.</para>
            </summary>
            
            <param name="Value">Value with which the greatest common divisor is computed.</param>
            <returns><c>Gcd(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.IsProbablePrime(System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Max(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the maximum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with this</param>
            
            <returns>Max(this, Value)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Min(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the minimum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with this</param>
            
            <returns><c>Min(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Mod(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator defined for the built-in int's.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M == null or M &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this^Exponent Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            If the Exponent is negative, then <c>this.ModInverse(M)^(-Exponent) Mod M)</c> is computed.
            The inverse of this only exists if this is relatively prime to M, otherwise an exception is thrown.</para>
            </summary>
            
            <param name="Exponent">The exponent</param>
            <param name="M">The modulus</param>
            
            <returns><c>this^Exponent Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or if Exponent&lt;0 and this is not relatively prime to M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModInverse(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>1/this Mod M</c>. 
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, M exclusive).
            If this is not relatively prime to M, then an exception is thrown.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>1/this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or, if this is not relatively prime to code M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this * Value</c>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <returns>Returns <c>this * Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Negate">
            <summary>
            Returns a new BigInteger whose value is the <c>-this</c>
            </summary>
            
            <returns><c>-this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.NextProbablePrime">
            <summary>
            Returns the smallest integer x &gt; this which is probably prime as a BigInteger instance.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <returns>Smallest integer &gt; this which is robably prime</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if this &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Not">
            <summary>
            Returns a new BigInteger whose value is <c>~this</c>.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <returns>Returns <c>~this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>
            </summary>
            
            <param name="Value">Value to be Or'ed with this</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Pow(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ProbablePrime(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Returns a random positive BigInteger instance in the range <c>[0, 2^(bitLength)-1]</c> which is probably prime.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Rnd">Random generator used to generate the new BigInteger</param>
            
            <returns>Returns probably prime random BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this % Divisor</c>.
            <para>Regarding signs this methods has the same behavior as the % operator on int's, 
            i.e. the sign of the remainder is the same as the sign of this.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>Returns <c>this % Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.SetBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N set.
            <para>The result is equivalent to <c>this | 2^n</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be set</param>
            
            <returns>Returns <c>this | 2^n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftLeft(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftRight(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>.
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Signum">
            <summary>
            Returns the sign of this BigInteger
            </summary>
            
            <returns>Returns -1 if this &lt; 0, 0 if this == 0, 1 if this > 0</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this - val</c>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns><c>this - val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.TestBit(System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
            
            <remarks>
            Implementation Note: Usage of this method is not 
            recommended as the current implementation is not efficient.
            </remarks>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToByteArray">
            <summary>
            Returns the two's complement representation of this BigInteger in a byte array
            </summary>
            
            <returns>Two's complement representation of this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToDouble">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToSingle">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString(System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ValueOf(System.Int64)">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value 
            </summary>
            
            <param name="Value">The value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be xor'ed with this</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create a BigInteger from a stream
            </summary
            >
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Get streaming object info
            </summary>
            
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigInteger instance and if this instance is equal to this BigInteger
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>Returns true if Obj is a BigInteger and this == Obj,  false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.GetHashCode">
            <summary>
            Returns a hash code for this BigInteger
            </summary> 
            
            <returns>Returns hash code for this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A + B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A - B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A * B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A / B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A Mod B</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator 
            defined for the built-in int's.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The modulus value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A Mod B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseAnd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be and'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A &amp; B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A | B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be Or'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A | B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_ExclusiveOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A ^ B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">Value to be xor'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A ^ B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_OnesComplement(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~X.
            <para>The result of this operation is <c>-X-1</c>.</para>
            </summary>
            
            <param name="X">Value to be unary reversed</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is the <c>-X</c>
            </summary>
            
            <param name="X">The value to be negated</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_RightShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X >> N</c>, if <c>N >= 0</c>; <c>X &lt;&lt; (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LeftShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X &lt;&lt; N</c> if N >= 0, <c>X >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if "A" is a BigInteger instance and if this instance is equal to the BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if "B" is a BigInteger and <c>A == B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is not equal to BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Single">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Double">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.String">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The int value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The long value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitCount">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitLength">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.LowestSetBit">
            <summary>
            Returns the position of the lowest set bit in the two's complement representation of this BigInteger.
            <para>If all bits are zero (this=0) then -1 is returned as result.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType">
            <summary>
            Specifies the Skein initialization type.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.Normal">
            <summary>
            Identical to the standard Skein initialization.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ZeroedState">
            <summary>
            Creates the initial state with zeros instead of the configuration block, then initializes the hash.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedState">
            <summary>
            Leaves the initial state set to its previous value, which is then chained with subsequent block transforms.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedConfig">
            <summary>
            Creates the initial state by chaining the previous state value with the config block, then initializes the hash.
            This starts a new UBI block type with the standard Payload type.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType">
            <summary>
            The Unique Block Iteration (UBI) options
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Key">
            <summary>
            A key that turns Skein into a MAC or KDF function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Config">
            <summary>
            The configuration block.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Personalization">
            <summary>
            A string that applications can use to create different functions for different uses.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.PublicKey">
            <summary>
            Used to hash the public key when hashing a message for signing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.KeyIdentifier">
            <summary>
            Used for key derivation.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Nonce">
            <summary>
            Nonce value for use in stream cipher mode and randomized hashing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Message">
            <summary>
            The normal message input of the hash function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Out">
            <summary>
            The output transform.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak">
            <summary>
            <para>The Unique Block Iteration (UBI) implementations, <see href="https://www.schneier.com/skein1.3.pdf">section 2.3</see>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.StartNewBlockType(VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType)">
            <summary>
            Starts a new UBI block type by setting BitsProcessed to zero, setting the first flag, and setting the block type.
            </summary>
            <param name="type">The UBI block type of the new block</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFirstBlock">
            <summary>
            Gets or sets the first block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFinalBlock">
            <summary>
            Gets or sets the final block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.TreeLevel">
            <summary>
            Gets or sets the current tree level.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BitsProcessed">
            <summary>
            Gets or sets the number of bits processed so far, inclusive.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BlockType">
            <summary>
            Gets or sets the current UBI block type.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.Tweak">
            <summary>
            The current Threefish tweak value.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256">
            <summary>
            <h3>Skein256: An implementation of the Skein digest with a 256 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance.
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256">
            <summary>
            <h3>SHA256: An implementation of the SHA-2 digest with a 256 bit digest return size.</h3>
            <para>The SHA-2<cite>Fips 180-4</cite> 256 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [32 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 32 bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BEToUInt32(System.Byte[],System.Int32)">
            <remarks>
            Big Endian to UInt32
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.UInt32ToBE(System.UInt32,System.Byte[],System.Int32)">
            <remarks>
            UInt32 to Big Endian
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.K1C">
            <remarks>
            the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256">
            <summary>
            <h3>Blake256: An implementation of the Blake digest with a 256 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Clone">
            <summary>
            Creates a shallow copy of the current Object
            </summary>
            
            <returns>A shallow copy of the current Object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.LittleEndian">
            <summary>
            This is a utility class containing data type conversions using little-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer into a byte array beginning at the specified offset
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to a byte array beginning at the specified offset.
            <para>No length checking is performed (i.e., if the integer cannot be encoded with <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The offset in output array</param>
            <param name="Offset">The byte array holding the output</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string of length 4 to an integer
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert an byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert a byte array of the given length beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array to a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded with <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array to an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG">
            <summary>
            <h3>An implementation of the Modular Exponentiation Generator random number generator: MODEXPG</h3>
            <para>Implements MODEXPG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.6</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new MODEXPG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">ModulusExponentPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime</param>
            <param name="G">Random Generator State</param>
            <param name="Y">Random Generator Seed</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2">
            <summary>
            <h3>PBKDF2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PBKDF2 as outlined in ISO 18033-2 <cite>ISO 18033</cite>.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PBKDF2(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> or a Mac.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="bullet">
            <item><description>ISO-18033-2: <see href="http://www.shoup.net/iso/std6.pdf">Specification</see>.</description></item>
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.#ctor">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given HMAC function
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PBKDF2.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX">
            <summary>
            <h3>TFX: An extended implementation of the Twofish encryption cipher.</h3>
            <para>TFX is an implementation of the Twofish<cite>Twofish</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TFX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>TFX extends the original design allowing it to accept the longer key length (512 bits).</para>
            
            <para>The number of diffusion rounds processed in the ciphers transformation method has also been extended, and is user configurable; 
            from the original 16 rounds, to a full 32 rounds of transformation. 
            This increase in key size eliminates brute force attacks, and the increase in the number of diffusion rounds makes cryptanalysis far more difficult.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">A 128-Bit Block Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX">
            <summary>
            <h3>RDX: An extended implementation of the Rijndael encryption cipher.</h3>
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, extended to use a 512 bit key</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/10" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 bytes wide.</description></item>
            </list>
            
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, the same one used in the AES<cite>Fips 197</cite> standard. 
            What has been done is to extend Rijndael so that it now accepts the longer key length (512 bits). 
            The extended key length provides more security against attacks that attempt to brute force the key, and also adds eight more rounds of diffusion.</para>
            
            <para>The increased number of rounds brings the total from 14 rounds with a 256 bit key, to 22 rounds with the 512 bit key size. 
            These added passes through the rounds function further disperse the input through row and column transpositions, and XORs with a longer expanded key array.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>AES Proposal: <see href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael</see>.</description></item>
            <item><description>Fips 197: Announcing the <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Advanced Encryption Standard (AES)</see></description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigMath">
            <summary>
            Class of number-theory related functions for use with integers represented as <c>int</c>'s or <c>BigInteger</c> objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Computes the binomial coefficient (n|t)
            </summary>
            
            <param name="X">The upper integer</param>
            <param name="T">The lower integer</param>
            
            <returns>Returns the binomialcoefficient (n|t) as BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.BitCount(System.Int32)">
            <summary>
            Get the number of ones in the binary representation of an integer <c>A</c>
            </summary>
            
            <param name="X">n integer</param>
            
            <returns>Returns the number of ones in the binary representation of an integer <c>A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given BigInteger
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(System.Int32)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int32)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the integer <c>N</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int64)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the long integer <c>N</c>
            </summary>
            
            <param name="X">The long integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigIntegers and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigInteger arrays and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger array</param>
            <param name="B">The second BigInteger array</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extended euclidian algorithm (computes Gcd and representation)
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>Returns <c>(d,u,v)</c>, where <c>d = Gcd(A,B) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGcd(System.Int32,System.Int32)">
            <summary>
            Extended euclidian algorithm (computes gcd and representation)
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The second integer</param>
            
            <returns>Returns <c>(g,u,v)</c>, where <c>g = Gcd(Abs(A),Abs(B)) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatLog(System.Single)">
            <summary>
            Calculation of a logarithmus of a float param
            </summary>
            
            <param name="X">The float value</param>
            
            <returns>Returns <c>Log(A)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatPow(System.Single,System.Int32)">
            <summary>
            Returns the int power of a base float, only use for small ints
            </summary>
            
            <param name="X">The float value</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(System.Int32)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Gcd(System.Int32,System.Int32)">
            <summary>
            Computes the greatest common divisor of the two specified integers
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The  second integer</param>
            
            <returns>Returns <c>Gcd(a, b)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntRoot(System.Int32,System.Int32)">
            <summary>
            Takes an approximation of the root from an integer base, using newton's algorithm
            </summary>
            
            <param name="X">The base to take the root from</param>
            <param name="Root">The root, for example 2 for a square root</param>
            
            <returns>Returns the integers base root</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntToOctets(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Convert a BigInteger to bytes
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns the BigInteger as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsIncreasing(System.Int32[])">
            <summary>
            Tests if the integers are incrementing
            </summary>
            
            <param name="A">The array to test</param>
            
            <returns>Returns <c>true</c> if array values are incrementing</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPower(System.Int32,System.Int32)">
            <summary>
            Tests whether an integer <c>a</c> is power of another integer <c>P</c>
            </summary>
            
            <param name="X">The first integer</param>
            <param name="P">The second integer</param>
            
            <returns>Returns n if A = P^n or -1 otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPrime(System.Int32)">
            <summary>
            Miller-Rabin-Test, determines wether the given integer is probably prime or composite.
            <para>This method returns <c>true</c> if the given integer is prime with probability <c>1 - 2^-20</c>.</para>
            </summary>
            
            <param name="X">The integer to test for primality</param>
            
            <returns>Returns <c>true</c> if the given integer is prime with probability 2*-100, otherwise <c>false</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsSmallPrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Short trial-division test to find out whether a number is not prime.
            <para>This test is usually used before a Miller-Rabin primality test.</para>
            </summary>
            
            <param name="Candidate">he number to test</param>
            
            <returns>Returns <c>true</c> if the number has no factor of the tested primes, <c>false</c> if the number is definitely composite</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Jacobi(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the value of the Jacobi symbol (A|B). 
            </summary>
            
            <param name="A">The integer value</param>
            <param name="B">The integer value</param>
            
            <returns>Returns value of the jacobi symbol (A|B)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Lcm(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Computation of the least common multiple of a set of BigIntegers
            </summary>
            
            <param name="Numbers">The set of numbers</param>
            
            <returns>Returns the lcm(Numbers)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LeastDiv(System.Int32)">
            <summary>
            Find and return the least non-trivial divisor of an integer <c>A</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns divisor p &gt;1 or 1 if A = -1,0,1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Double)">
            <summary>
            Calculates the logarithm to the base 2
            </summary>
            
            <param name="X"> double value</param>
            
            <returns>Returns log_2(x)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Int64)">
            <summary>
            Calculate the logarithm to the base 2
            </summary>
            
            <param name="X">Any long value &gt;=1</param>
            
            <returns>Returns <c>log_2(x)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.MaxPower(System.Int32)">
            <summary>
            Compute the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>
            </summary>
            
            <param name="X">An integer</param>
            
            <returns>Returns the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>, <c>0</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Mod(System.Int64,System.Int64)">
            <summary>
            Returns a long integer whose value is <c>(A mod M</c>). 
            <para>This method differs from <c>%</c> in that it always returns a <c>non-negative</c> integer.</para>
            </summary>
            
            <param name="X">The value on which the modulo operation has to be performed</param>
            <param name="M">The modulus.</param>
            
            <returns>Returns <c>A mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int32,System.Int32)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int64,System.Int64)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModPow(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E mod N</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            <param name="N">The modulus</param>
            
            <returns>Returns <c>A<sup>E</sup> mod N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextPrime(System.Int64)">
            <summary>
            Computes the next prime greater than N
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the specified certainty
            </summary>
            
            <param name="X">An integer number</param>
            <param name="Certainty">The certainty that the generated number is prime</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the default certainty (20)
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>The next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextSmallerPrime(System.Int32)">
            <summary>
            Returns the largest prime smaller than the given integer
            </summary>
            
            <param name="X"> upper bound</param>
            
            <returns>Returns the largest prime smaller than <c>N</c>, or <c>1</c> if <c>N &lt;= 2</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[])">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes used to create the BigInteger</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Order(System.Int32,System.Int32)">
            <summary>
            Determines the order of G modulo P, P prime and 1 &lt; g &lt; p; This algorithm is only efficient for small P
            </summary>
            
            <param name="G">An integer with 1 &lt; G &lt; P</param>
            <param name="P">The prime</param>
            
            <returns>Returns the order k of g (that is k is the smallest integer with G^k = 1 mod P</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int64,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ReduceInto(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Reduces an integer into a given interval
            </summary>
            
            <param name="X">The integer</param>
            <param name="Begin">Left bound of the interval</param>
            <param name="End">Right bound of the interval</param>
            
            <returns>Returns <c>N</c> reduced into <c>[Begin,End]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Ressol(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the square root of a BigInteger modulo a prime employing the Shanks-Tonelli algorithm
            </summary>
            
            <param name="X">The value out of which we extract the square root</param>
            <param name="P">The prime modulus that determines the underlying field</param>
            
            <returns>Returns a number <c>B</c> such that B^2 = A (mod P) if <c>A</c> is a quadratic residue modulo <c>P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            <param name="SecRnd">An instance of the SecureRandom class</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.SquareRoot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extract the truncated square root of a BigInteger
            </summary>
            
            <param name="X">A value out of which we extract the square root</param>
            
            <returns>Returns the truncated square root of <c>a</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LogBKM(System.Double)">
            <summary>
            BKM Algorithm to calculate logarithms to the base 2
            </summary>
            
            <param name="X"> double value with 1&lt;= arg&lt;= 4.768462058</param>
            
            <returns>Returns log_2(arg)</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC">
            <summary>
            <h3>SHA512 Hash based Message Authentication Code Wrapper using SHA-2 512.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 64 bytes, (512 bits).</description></item>
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA512HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt">
            <summary>
            An Ring-LWE cipher implementation
            </summary>
            
            <example>
            <description>Example of encrypting and decrypting an array:</description>
            <code>
            RLWEParameters encParams = new RLWEParameters(512, 12289, 12.18, new byte[] { 2, 5, 1 }))
            RLWEKeyGenerator keyGen = new RLWEKeyGenerator(encParams);
            IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
            
            byte[] data = new byte[64];
            byte[] enc, dec;
            
            // encrypt an array
            using (RLWEEncrypt cipher = new RLWEEncrypt(encParams))
            {
                cipher.Initialize(true, new RLWEKeyPair(keyPair.PublicKey));
                enc = cipher.Encrypt(data);
            }
            
            // decrypt the cipher text
            using (RLWEEncrypt cipher = new RLWEEncrypt(encParams))
            {
                cipher.Initialize(false, new RLWEKeyPair(keyPair.PrivateKey));
                dec = cipher.Decrypt(enc);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">version</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters)">
            <summary>
            Initialize this class; Prng is created automatically
            </summary>
            
            <param name="CipherParams">The cipher engine</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class with an initialized Prng
            </summary>
            
            <param name="CipherParams">The cipher parameters</param>
            <param name="Engine">The initialized cipher prng</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized, or input text is too long</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <param name="Key">The key</param>
            
            <returns>The size of the key</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized, or key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="Encryption">When true cipher is for encryption, if false, decryption</param>
            <param name="KeyPair">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair"/> containing the RLWE public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Engine">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.MaxCipherText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ParallelUtils">
            <summary>
            This class is a utility class for parallel processing
            <para>http://blogs.msdn.com/b/pfxteam/archive/2009/08/12/9867246.aspx</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.Loop(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            An infinite parallel loop function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Func{System.Boolean},System.Action)">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.ForceLinear">
            <summary>
            Get/Set: Force uni-processing (IsParallel returns false)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.IsParallel">
            <summary>
            Get: Returns true for multi processor system
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Logical">
            <summary>
            This class implements some logical operations over BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Not</description></item>
            <item><description>And</description></item>
            <item><description>AndNot</description>/></item>
            <item><description>Or</description>/></item>
            <item><description>Xor</description>/></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Not(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~Value.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed</param>
            
            <returns>Returns <c>~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one.
            </summary>
            
            <param name="Value">The value to be And'ed with X</param>
            <param name="X">The second value</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>Value &amp; X</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed and then And'ed</param>
            <param name="X">The second value</param>
            
            <returns><c>Value &amp; ~X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>.
            </summary>
            
            <param name="Value">Value to be Or'ed</param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be Xor'ed </param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            <h3>This class represents immutable arbitrary precision decimal numbers</h3>
            
            
            <description>Immutable, arbitrary-precision signed decimal numbers.</description> 
            <para>A BigDecimal consists of an arbitrary precision integer unscaled valueand a 32-bit integer scale.  
            If zero or positive, the scale is the number of digits to the right of the decimal point.  
            If negative, the unscaled value of the number is multiplied by ten to the power of the negation of the scale.  
            The value of the number represented by the BigDecimal is therefore (unscaledValue times; 10 pow -scale).</para>
            </summary>
            
            <example>
            <description>Creating a BigDecimal:</description>
            <code>
            BigDecimal p = BigDecimal(bigInt);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.2.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <para>The BigDecimal class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion.  
            The ToString() method provides a canonical representation of a BigDecimal.</para>
            
            <para>The BigDecimal class gives its user complete control over rounding behavior.  
            If no rounding mode is specified and the exact result cannot be represented, an exception is thrown;
            otherwise, calculations can be carried out to a chosen precision and rounding mode by supplying an appropriate MathContext object to the operation.  
            In either case, eight rounding modes are provided for the control of rounding.  
            Using the integer fields in this class (such as HalfUp) to represent rounding mode is largely obsolete; 
            the enumeration values of the RoundingMode enum, (such as HalfUp) should be used instead.</para>
            
            <para>When a MathContext object is supplied with a precision setting of 0 (for example, Unnecessary), arithmetic operations are exact, 
            as are the arithmetic methods which take no MathContext object. 
            As a corollary of computing the exact result, the rounding mode setting of a MathContext object with a precision setting of 0 is not used and thus irrelevant.  
            In the case of divide, the exact quotient could have an infinitely long decimal expansion; for  example, 1 divided by 3.  
            If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an ArithmeticException is thrown.  
            Otherwise, the exact result of the division is returned, as done for other operations.</para>
            
            <para>When the precision setting is not 0, the rules of BigDecimal arithmetic are broadly compatible with selected 
            modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4).  
            Unlike those standards, BigDecimal includes many rounding modes. Any conflicts between these ANSI standards and the BigDecimal specification are resolved in favor of BigDecimal.</para>
            
            <para>Since the same numerical value can have different representations (with different scales), the rules of arithmetic
            and rounding must specify both the numerical result and the scale used in the result's representation.</para>
            
            <para>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when
            the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned.</para>
            
            <para>First, the total number of digits to return is specified by the MathContext's Precision} setting; this determines the result's <c>Precision</c>.  
            The digit count starts from the leftmost nonzero digit of the exact result.  The rounding mode determines how any discarded trailing digits affect the returned result.</para>
            
            <para>For all arithmetic operators , the operation is carried out as though an exact intermediate result were first calculated and then
            rounded to the number of digits specified by the precision setting (if necessary), using the selected rounding mode.  
            If the exact result is not returned, some digit positions of the exact result are discarded.  
            When rounding increases the magnitude of the returned result, it is possible for a new digit position to be created by a carry propagating to a leading "9" digit.
            For example, rounding the value 999.9 to three digits rounding up would be numerically equal to one thousand, represented as <c>100 times 10 pow 1</c>.  
            In such cases, the new "1" is the leading digit position of the returned result.</para>
            
            <para>Besides a logical exact result, each arithmetic operation has a preferred scale for representing a result.  
            The preferred scale for each operation is listed in the table below.</para>
            
            <description>Preferred Scales for Results of Arithmetic Operations</description>
            <list type="table">
            <item><description>Operation: Preferred Scale of Result</description></item>
            <item><description>Add: Max(Addend.Scale(), Augend.Scale())</description></item>
            <item><description>Subtract: Max(Minuend.Scale(), Subtrahend.Scale())</description></item>
            <item><description>Multiply: Multiplier.Scale() + Multiplicand.Scale()</description></item>
            <item><description>Divide: Dividend.Scale() - Divisor.Scale()</description></item>
            </list>
            
            <para>These scales are the ones used by the methods which return exact arithmetic results; 
            except that an exact divide may have to use a larger scale since the exact result may have more digits.  
            For example, <c>1/32</c> is <c>0.03125</c>.</para>
            
            <para>Before rounding, the scale of the logical exact intermediate result is the preferred scale for that operation.  
            If the exact numerical result cannot be represented in Precision digits, rounding selects the set of digits to return and the scale
            of the result is reduced from the scale of the intermediate result to the least scale which can represent the Precision digits actually returned. 
            If the exact result can be represented with at most Precision digits, the representation of the result with the scale closest to the preferred scale is returned.  
            In particular, an exactly representable quotient may be represented in fewer than Precision digits by removing trailing zeros and decreasing the scale.  
            For example, rounding to three digits using the Floor rounding mode.</para>
            
            <para>Note that for add, subtract, and multiply, the reduction in scale will equal the number of digit positions of the exact result which are discarded. 
            If the rounding causes a carry propagation to create a new high-order digit position, an additional digit of the result is discarded than when no new digit position is created.</para>
            
            <para>Other methods may have slightly different rounding semantics.
            For example, the result of the Pow method using the Pow(int, MathContext) specified algorithm can occasionally differ from the rounded mathematical result by more
            than one unit in the last place, one Ulp.</para>
            
            <para>Two types of operations are provided for manipulating the scale of a BigDecimal: scaling/rounding operations and decimal point motion operations.  
            Scaling/rounding operations SetScale and Round}) return a BigDecimal whose value is approximately (or exactly) equal
            to that of the operand, but whose scale or precision is the specified value; that is, they increase or decrease the precision
            of the stored number with minimal effect on its value.  
            Decimal point motion operations (MovePointLeft and MovePointRight) return a BigDecimal created from the operand by moving the decimal point a specified distance in the specified direction.</para>
            
            Each BigDecimal instance is represented with a unscaled arbitrary precision mantissa (the unscaled value) and a scale. 
            <para>The value of the "BigDecimal is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/> 10^(-<see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>).
            Since the ToString() method is overriden by this class and it changes the state of the object causing Heisenbugs
            for debuggability we add the attribute DebuggerDisplay that points to a method that doesn't change it.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Zero">
            <summary>
            The constant zero as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.One">
            <summary>
            The constant one as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ten">
            <summary>
            The constant ten as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#cctor">
            <summary>
            Initializes static members of the BigDecimal class.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal, 
            accepting the same sequence of characters as the BigDecimal(String) constructor,
            while allowing a sub-array to be specified.
            <para>Note that if the sequence of characters is already available within a character array, 
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">Array that is the source of characters</param>
            <param name="Offset">Offset first character in the array to inspect.</param>
            <param name="Length">Number of characters to consider.</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null data array is passed</exception>
            <exception cref="T:System.FormatException">Thrown if an invalid char array is passed, or scale is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Offset">Offset of the first character in the array to inspect</param>
            <param name="Length">Number of characters to consider</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[])">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance.</param>
            <param name="Context">The context to use</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^-scale</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            
            <exception cref="T:System.NullReferenceException">Throws if UnscaledValue == null</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^(-scale). 
            The result is rounded according to the specified math context</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0. The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.
            The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The scale of the result is the same as the scale of Abs(this).</para>
            </summary>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            <param name="Context">The rounding mode and precision for the result of this operation</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> or <paramref name="Context"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AddAndMult10(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Add and Multiply by 10
            </summary>
            
            <param name="Value">The value to add and multiply</param>
            <param name="Augend">The value to be added</param>
            <param name="DiffScale">The differential scale</param>
            
            <returns>
            The result of the Add and Multiply operation
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Compares this BigDecimal with Value.
            <para>Returns one of the three values 1, 0, or -1.
            The method behaves as if Subtract(Value) is computed.
            If this difference is > 0 then 1 is returned, if the difference is &lt; 0 then -1 is returned, 
            and if the difference is 0 then 0 is returned.
            This means, that if two decimal instances are compared which are equal in value but differ in scale, 
            then these two instances are considered as equal.</para>
            </summary>
            <param name="Value">Value to be compared with this</param>
            
            <returns>
            ReturnS 1 if this > Value, -1 if this &lt; Value, 0 if this == Value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0 or the result cannot be represented exactly.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The result is rounded according to the passed context.
            If the passed math context specifies precision 0, then this call is equivalent to <c>Divide(Divisor)</c></para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid rounding mode is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder <c>this % divisor</c> at index 1. 
            <para>The quotient is rounded down towards zero to the next integer.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            DivideToIntegralValue(Divisor), Remainder(divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder at index 1.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of Context > 0 and the integral part requires more digits, then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            [DivideToIntegralValue(Divisor), Remainder(Divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            For example, <c>0.5/0.2 = 2</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of <c>Context &gt; 0</c> and the integral part requires more digits, 
            then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if quotient won't fit in 'Context.Precision()' digits </exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Max(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the maximum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with</param>
            
            <returns>
            <c>Max(this, Value)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Min(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the minimum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with</param>
            
            <returns>
            <c>Min(this, val)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointLeft(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the left.
            <para>If <c>N &lt; 0</c> then the decimal point is moved -N places to the right.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointLeft(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^(-N)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointRight(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the right. 
            <para>If N &lt; 0 then the decimal point is moved -N places to the left.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointRight(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of placed the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^n</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            
            <returns>
            <c>this * Multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * multiplicand</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this * multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <returns>
            <c>-this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            The result is <c>-this</c> rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <returns>
            <c>+this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>+this</c> rounded according to the passed context 
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The scale of the result is N times the scales of this.
            <c>x.pow(0)</c> returns 1, even if x == 0.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.
            The specified rounding mode Context is used for the division only.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision to be used</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Round(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is this, rounded according to the passed context.
            <para>If Context.Precision = 0, then no rounding is performed.
            If Context.Precision and Context.RoundingMode == UNNECESSARY, then an ArithmeticException 
            is thrown if the result cannot be represented exactly within the given precision.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            This rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ScaleByPowerOfTen(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this 10^ N</c>.
            <para>The scale of the result is Scale() - N.
            The precision of the result is the precision of this.
            This method has the same effect as MovePointRight, except that the precision is not changed.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this 10^ N</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing zeros are removed.
            If the trailing digits are not zeros then an ArithmeticException is thrown.
            If no exception is thrown, then the following equation holds: <c>x.SetScale(s).CompareTo(x) == 0</c>.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            A new BigDecimal instance with the specified scale.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            In this case no rounding is necessary.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            In this case no rounding is necessary.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if RoundMode is not a valid rounding mode</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Signum">
            <summary>
            Returns the sign of this BigDecimal
            </summary>
            
            <returns>
            Returns <c>-1</c> if <c>this &lt; 0</c>, <c>0</c> if <c>this == 0</c>, <c>1</c> if <c>this &gt; 0</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.StripTrailingZeros">
            <summary>
            Returns a new BigDecimal instance with the same value as this but with a 
            unscaled value where the trailing zeros have been removed.
            <para>If the unscaled value of this has n trailing zeros, 
            then the scale and the precision of the result has been reduced by n.
            </para>
            </summary>
            
            <returns>
            A new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal}whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a big integer instance
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigIntegerExact">
            <summary>
            Returns this BigDecimal as a big integer instance if it has no fractional part.
            <para>If this BigDecimal has a fractional part, i.e. if rounding would be necessary, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a big integer value
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if rounding is necessary</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToByteExact">
            <summary>
            Returns this BigDecimal as a byte value if it has no fractional part and 
            if its value fits to the byte range ([-128..127]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a byte value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToDouble">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a double value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToEngineeringString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - Precision >= 6 then engineering notation is used.
            Engineering notation is similar to the scientific notation except that the exponent is made to be a multiple of 3 such that the integer part is >= 1 and &lt; 1000.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in engineering notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt16Exact">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a short value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as an int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32Exact">
            <summary>
            Returns this BigDecimal as an int value. Any fractional part is discarded.
            <para>Returns this BigDecimal as a int value if it has no fractional part and if 
            its value fits to the int range ([-2^{31}..2^{31}-1]).
            If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            This BigDecimal as a int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64Exact">
            <summary>
            Returns this BigDecimal as a long value if it has no fractional part and if its value fits to the int range ([-2^{63}..2^{63}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToPlainString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>No scientifi notation is used. This methods adds zeros where necessary.
            If this string representation is used to create a new instance, 
            this instance is generally not identical to this as the precision changes.
            <c>x.Equals(new BigDecimal(x.ToPlainString())</c> usually returns false.
            <c>x.CompareTo(new BigDecimal(x.ToPlainString())} returns 0</c></para>
            </summary>
            
            <returns>
            A string representation of this without exponent part.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToSingle">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a float value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ulp">
            <summary>
            Returns the unit in the last place (ULP) of this BigDecimal instance.
            <para>An ULP is the distance to the nearest big decimal with the same precision.</para>para>
            </summary>
            
            <returns>
            Returns unit in the last place (ULP) of this BigDecimal instance
            </returns>
            
            <remarks>
            <para>The amount of a rounding error in the evaluation of a floating-point operation is 
            often expressed in ULPs. An error of 1 ULP is often seen as a tolerable error.
            For class BigDecimal, the ULP of a number is simply 10^(-scale).
            For example, {@code new BigDecimal(0.1).ulp()} returns {@code 1E-55}.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Double)">
            <summary>
            Returns a new BigDecimal instance whose value is equal to value.
            <para>The new decimal is constructed as if the BigDecimal(String) constructor is called
            with an argument which is equal to Double.toString(val). 
            For example, ValueOf("0.1")} is converted to (unscaled=1, scale=1), although the double 0.1 cannot be
            represented exactly as a double value. In contrast to that, a new BigDecimal(0.1) instance has the value 
            0.1000000000000000055511151231257827021181583404541015625 with an unscaled value 
            1000000000000000055511151231257827021181583404541015625}and the scale 55.</para>
            </summary>
            
            <param name="Value">Double value to be converted to a {@code BigDecimal</param>
            
            <returns>
            BigDecimal instance with the value 
            </returns>
            
            <exception cref="T:System.FormatException">Thrown if Value is infinite or not a number</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to <paramref name="UnscaledVal"/>. 
            <para>The scale of the result is <c>0</c>, and its unscaled value is <paramref name="UnscaledVal"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <paramref name="UnscaledVal"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64,System.Int32)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to 
            <paramref name="UnscaledVal"/> 10^(-<paramref name="Scale"/>). 
            <para>The scale of the result is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>, and its unscaled value is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The unscaled value to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <param name="Scale">The scale to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.</param>
            
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <c>UnscaledVal * 10^(-scale)</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AproxPrecision">
            <summary>
            If the precision already was calculated it returns that value, otherwise it calculates a very good approximation efficiently .
            </summary>
            
            <returns>
            Returns an approximation of Precision() value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int64)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue"> The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int32)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue">The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideBigIntegers(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide big integers
            </summary>
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> remainder
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DividePrimitiveLongs(System.Int64,System.Int64,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide primitive longs
            </summary>
            
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DoubleToLongBits(System.Double)">
            <summary>
            Convert a double to long
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>
            The long integer value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetUnscaledValue">
            <summary>
            The get unscaled value
            </summary>
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetZeroScaledBy(System.Int64)">
            <summary>
            It returns the value 0 with the most approximated scale of type int
            </summary>
            
            <param name="LongScale">The scale to which the value 0 will be scaled</param>
            
            <returns>
            The value 0 scaled by the closer scale of type int
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.InplaceRound(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            It does all rounding work of the public method Round(MathContext), performing an inplace rounding without creating a new object.
            </summary>
            
            <param name="Context">MathContext for perform the rounding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNaN(System.Double)">
            <summary>
            Test if the value is Not a Number
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if NaN, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNegativeZero(System.Double)">
            <summary>
            Test if the value is negative zero
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if negative zero, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsZero">
            <summary>
            Is BigDecimal zero
            </summary>
            
            <returns>
            True if BigDecimal is zero, otherwise fals
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.LongCompareTo(System.Int64,System.Int64)">
            <summary>
            Compare two longs
            </summary>
            
            <param name="A">The first value</param>
            <param name="B">The second value</param>
            
            <returns>
            Returns 1 for A more than B, -1 for A less B, and 0 for equal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePoint(System.Int64)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved to the right based on the scale.
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            BigDecimal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.RoundingBehavior(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Return an increment that can be -1, 0, or 1, depending of RoundingMode
            </summary>
            
            <param name="ParityBit">Can be 0 or 1, it's only used in the case HALF_EVEN</param>
            <param name="Fraction">The type of rounding Mantisa to be analyzed</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            Returns the carry propagated after rounding
            </returns>
            
            <exception cref="T:System.ArithmeticException"></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetUnscaledValue(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            The set unscaled value
            </summary>
            <param name="unscaledValue">
            The unscaled value
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SmallRound(VTDev.Libraries.CEXEngine.Numeric.MathContext,System.Int32)">
            <summary>
            This method implements an efficient rounding for numbers which unscaled value fits in the type long.
            </summary>
            
            <param name="Context">The context to use</param>
            <param name="DiscardedPrecision">The number of decimal digits that are discarded</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToIntScale(System.Int64)">
            <summary>
            It tests if a scale of type long fits in 32 bits.
            It returns the same scale being casted to int type when is possible, otherwise throws an exception.
            </summary>
            
            <param name="LongScale">A 64 bit scale</param>
            <returns>
            A 32 bit scale when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws ArithmeticException when Scale doesn't fit in int type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToStringInternal">
            <summary>
            The to string internal.
            </summary>
            <returns>
            The <see cref="T:System.String"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueExact(System.Int32)">
            <summary>
            Counts the number of bits of value and checks if it's out of the range of the primitive type.
            </summary>
            
            <param name="BitLengthOfType">umber of bits of the type whose value will be calculated</param>
            
            <returns>
            The exact value of the integer part of BigDecimal when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws if rounding is necessary or the number don't fit in the primitive type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigDecimal instance and if this instance is equal to this big decimal.
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, <c>1.0 (10*10^(-1))</c> is not equal to <c>1.00 (100*10^(-2))</c>.
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>
            Returns true if Obj is a BigDecimal and this == Obj
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetHashCode">
            <summary>
            Returns a hash code for this BigDecimal
            </summary>
            
            <returns>
            Hash code for this
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToString">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in scientific notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class
            </summary>
            
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            The get object data
            </summary>
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Add two <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> values.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigDecimal whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A - B</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns><c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A / B</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor B</param>
            
            <returns><c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A % B</c>.
            <para>The remainder is defined as <c>A - DivideToIntegralValue(B) * B</c>.</para>
            </summary>
            
            <param name="A">The value</param>
            <param name="B">The divisor</param>
            
            <returns><c>A % B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand</param>
            
            <returns><c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryPlus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>+A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>+A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>-A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if "A" is a BigDecimal instance and if this instance is equal to "B".
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)).
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if "B" is a BigDecimal and A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is not equal to BigDecimal "B".
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int16">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a short value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Single">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a float value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Double">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a double value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.String">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns a string representation of this in scientific notation if necessary</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Double)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <returns>A new BigDecimal instance</returns>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Precision">
            <summary>
            Returns the precision of this BigDecimal.
            <para>The precision is the number of decimal digits used to represent this decimal.
            It is equivalent to the number of digits of the unscaled value.
            The precision of 0 is 1 (independent of the scale).</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale">
            <summary>
            Returns the scale of this BigDecimal.
            <para>The scale is the number of digits behind the decimal point.
            The value of this BigDecimal is the unsignedValue * 10^(-scale). 
            If the scale is negative, then this BigDecimal represents a big integer.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue">
            <summary>
            Returns the unscaled value (mantissa) of this BigDecimal instance as a BigInteger.
            <para>The unscaled value can be computed as this <c>10^(scale)</c>.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator II random number generator : QCG-II.</h3>
            <para>Implements QCGII as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.3</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG2())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue2Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations; must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Reset">
            <summary>
            Resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">
            <summary>
            <h3>An implementation of a Hash based Message Authentication Code: HMAC<cite>Fips 198-1</cite>.</h3>
            <para>A HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>.</description></item>
            <item><description>Block size is the Digests engines block size.</description></item>
            <item><description>Digest size is the Digest engines digest return size.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new HMAC(new SHA256Digest(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto">VTDev.Libraries.CEXEngine.Crypto Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the digest
            </summary>
            
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>HMAC hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Completes processing and returns the HMAC code
            </summary>
            
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            
            <returns>Hash size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize"/></para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the IKM of the KeyParams parameter is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the IKM is less than digest size</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Reset">
            <summary>
            Reset and initialize the underlying digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Update(System.Byte)">
            <summary>
            Update the digest with 1 byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX">
            <summary>
            <h3>THX: A Twofish Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>THX is an implementation of the Twofish<cite>Twofish</cite> block cipher combined with an HKDF powered Key Schedule.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new THX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>The number of transformation rounds processed is also user definable; from the standard 16 rounds, to a full 32 rounds of transformation.</para>
            
            <para>The key schedule in THX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even the Twofish key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            THX is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyGenerator">
            <summary>
            This class implements key pair generation of the Ring-LWE Public Key Cryptosystem.
            </summary>
            <example>
            <description>Example of creating a keypair:</description>
            <code>
            RLWEParameters encParams = RLWEParameters(512, 12289, 12.18, new byte[] { 2, 5, 1 }))
            RLWEKeyGenerator keyGen = new RLWEKeyGenerator(encParams);
            IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE RLWEPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">VTDev.Libraries.CEXEngine.Crypto.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CiphersParams">The RLWEParameters instance containing the cipher settings</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if a Prng that requires pre-initialization is used; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, 
            i.e. PBPrng, DGCPrng, or CTRPrng
            </summary>
            
            <param name="CiphersParams">The RLWEParameters instance containing thecipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyGenerator.GenerateKeyPair">
            <summary>
            Generate an encryption Key pair
            </summary>
            
            <returns>A RLWEKeyPair containing public and private keys</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator I random number generator: QCG-I</h3>
            <para>Implements QCGI as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.2</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG1())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue1Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG">
            <summary>
            <h3>An implementation of a Blum-Blum-Shub random number generator.</h3>
            <para>Implements BBSG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.8</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new BBSG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            <item><description>Cryptographic Secure Pseudo-Random Bits Generation: <cite>Blum-Blum-Shub</cite>The Blum-Blum-Shub Generator.</description></item>
            <item><description>Handbook of Applied Cryptography Chapter 5<cite>Handbook of Applied Cryptography</cite>: Pseudorandom Bits and Sequences.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">BBSPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Primes, and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="X">Random Generator State (X = X ** 2 mod N)</param>
            <param name="P">P Random Prime</param>
            <param name="Q">Q Random Prime</param>
            <param name="N">Random Prime (N = P * Q)</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P or Q is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5">
            <summary>
            <h3>PKCS5 V2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PKCS5 Version 2, as outlined in RFC 2898<cite>RFC 2898</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PKCS5(new SHA512(), 10000))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(System.Int32)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Iterations">The number of cycles used to produce output</param>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Hmac is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX">
            <summary>
            <h3>SHX: A Serpent cipher extended with an HKDF powered Key Schedule.</h3>
            <para>SHX is a Serpent<cite>Serpent</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, 64, 80, 96 and 128, default is 64.</description></item>
            </list>
            
            <para>It also takes a user defined number of rounds between 32 (the standard number of rounds), all the way up to 128 rounds in 8 round sets. 
            A round count of 40 or 48 is more than sufficient, as theoretical attacks to date are only able to break up to 12 rounds; and would require an enormous amount of memory and processing power.
            The transform in SHX is identical to the Serpent implementation SPX, it process rounds by first moving the byte input array into 4 integers, then processing the rounds in a while loop. 
            Each round consists of an XOR of each state word (<math>Rn</math>) with a key, an S-Box transformation of those words, and then a linear transformation. 
            Each of the 8 S-Boxes are used in succession within a loop cycle. The final round XORs the last 4 keys with the state and shifts them back into the output byte array.</para>
            
            <para>The key schedule in SHX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            SHX is capable of processing up to 128 rounds, that is four times the number of rounds used in a standard implementation of Serpent. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container.<para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib0(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng">
            <summary>
            <h3>An implementation of a Cryptographically Secure PRNG using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random number generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CSPRng())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">
            <summary>
            <h3>HKDF: An implementation of an Hash based Key Derivation Function.</h3>
            <para>HKDF as outlined in RFC 5869<cite>RFC 5869</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new HKDF(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 5869: <see href="http://tools.ietf.org/html/rfc5869">Specification</see>.</description></item>
            <item><description>HKDF Scheme: <see href="http://tools.ietf.org/html/rfc5869">Whitepaper</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a HKDF Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac)">
            <summary>
            Creates a HKDF Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Hmac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX">
            <summary>
            <h3>RHX: A Rijndael Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>RHX is a Rijndael<cite>Rijndael</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            </revisionHistory>
            
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The key schedule in RHX is the defining difference between this and a standard version of Rijndael<cite>Rijndael</cite>; 
            instead of using a simple inline function to expand the user supplied key into a larger working array, it uses a hash based pseudo-random generator to create the working key.</para>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds are 10 to 38, default is 22.</description></item>
            </list>
            
            <para>HKDF<cite>RFC 5869</cite> is a key derivation function that uses a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> property contains available sizes</param>
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes"/> property contains available sizes</param>
            <param name="KeyEngine"><para>The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> 
            implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/></para>.</param>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid block size or invalid rounds count are used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the HKDF Ikm is an invalid size.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and initialize state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.CharUtils">
            <summary>
            This class is a utility class for manipulating char arrays
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MIN_RADIX">
            <summary>
            Min radix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MAX_RADIX">
            <summary>
            Max radix
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.CharAt(System.String,System.Int32)">
            <summary>
            Get the char value at a specified index within a string
            </summary>
            
            <param name="Value">String to parse</param>
            <param name="Index">Index of value</param>
            
            <returns>Char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Clone(System.Char[])">
            <summary>
            Return a clone of the given char array. No null checks are performed.
            </summary>
            
            <param name="A">The array to clone</param>
            
            <returns>The clone of the given array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Equals(System.Char[],System.Char[])">
            <summary>
            Compare two char arrays. No null checks are performed.
            </summary>
            
            <param name="A">The char byte array</param>
            <param name="B">The second char array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ForDigit(System.Int32,System.Int32)">
            <summary>
            Get the char representation of an iteger
            </summary>
            
            <param name="Digit">The digit to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArray(System.Char[])">
            <summary>
            Convert the given char array into a byte array.
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArrayForPBE(System.Char[])">
            <summary>
            Convert the given char array into a byte array for use with PBE encryption
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char,System.Int32)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New integer value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.String)">
            <summary>
            Convert a string to an integer
            </summary>
            
            <param name="Value">String to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.MathContext">
            <summary>
            Immutable objects describing settings such as rounding mode and digit precision for the numerical operations 
            provided by class <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal128">
            <summary>
            A MathContext which corresponds to the IEEE 754r quadruple decimal precision format: 34 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal32">
            <summary>
            A MathContext which corresponds to the IEEE 754r single decimal precision format: 7 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal64">
            <summary>
            A MathContext which corresponds to the IEEE 754r double decimal precision format: 16 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Unlimited">
            <summary>
            A MathContext for unlimited precision with RoundingMode.HalfUp rounding
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32)">
            <summary>
            Constructs a new MathContext with the specified precision and with the rounding mode RoundingMode.HalfUp.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Constructs a new MathContext with the specified precision and with the specified rounding mode.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
            <param name="RoundingMode">The rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the Precision is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.String)">
            <summary>
            Constructs a new MathContext from a string.
            <para>The string has to specify the precision and the rounding mode to be used and has to follow the following syntax:
            "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;"
            This is the same form as the one returned by the ToString method.</para>
            </summary>
            
            <param name="Value">A string describing the precision and rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the string is not in the correct format or if the Precision specified is &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.Equals(System.Object)">
            <summary>
            Returns true if Obj is a MathContext with the same precision setting and the same rounding mode as this MathContext instance.
            </summary>
            
            <param name="Obj">bject to be compared</param>
            
            <returns>Returns true if this MathContext instance is equal to the Obj argument, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.GetHashCode">
            <summary>
            Returns the hash code for this MathContext instance
            </summary>
            
            <returns>Returns the hash code for this MathContext</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.ToString">
            <summary>
            Returns the string representation for this MathContext instance
            <para>The string has the form "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;" 
            where &lt;Precision&gt; is an integer describing the number of digits used for operations and
            &lt;RoundingMode&gt; is the string representation of the rounding mode.</para>
            </summary>
            
            <returns>Returns a string representation for this MathContext instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.Precision">
            <summary>
            Returns the precision.
            <para>The precision is the number of digits used for an operation.</para>
            </summary>
            
            <remarks>
            <para>Results are rounded to this precision.
            The precision is guaranteed to be non negative.
            If the precision is zero, then the computations have to be performed exact,
            results are not rounded in this case.</para></remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.RoundingMode">
            <summary>
            Returns the rounding mode.
            <para>The rounding mode is the strategy to be used to round results.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg">
            <summary>
            <h3>PBKDF2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PBKDF2 as outlined in ISO 18033-2 <cite>ISO 18033</cite>.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PBKDF2(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/28/15" version="1.3.1.1" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> or a <see cref="!:Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="table">
            <item><description>ISO-18033-2: <see href="http://www.shoup.net/iso/std6.pdf">Specification</see>.</description></item>
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given HMAC function
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg">
            <summary>
            <h3>CTRDrbg: An implementation of a Encryption Counter based Deterministic Random Byte Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new CTRDrbg(new RDX()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="!:VTDev.Libraries.CEXEngine.Crypto.SymmetricEngines">cipher</see>.</description></item>
            <item><description>Parallelized by default on a multi processer system when an input byte array of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize"/> bytes or larger is used.</description></item>
            <item><description>Parallelization can be disabled using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel"/> property.</description></item>
            <item><description>The <see cref="!:CTRDrbg(IBlockCipher, bool)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be: cipher key size +  cipher block size in length.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean,System.Int32)">
            <summary>
            Creates a CTR Bytes Generator using a block cipher
            </summary>
            
            <param name="Cipher">The block cipher</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> on this class is called</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt, ikm, or nonce is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus counter size, both are updated. 
            If Seed size is equal to counter size (16 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel">
            <summary>
            Get/Set Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ProcessorCount">
            <summary>
            Processor count
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize">
            <summary>
            Get: Minimum input size to trigger parallel processing
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey">
            <summary>
            A Ring-LWE private key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.#ctor(System.Int32,System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The number of coefficients</param>
            <param name="R2">The private key as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array.
            <para>The array can contain only the public key.</para>
            </summary>
            
            <param name="KeyArray">The byte array containing the key</param>
            
            <returns>An initialized MPKCPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a byte array.
            <para>The stream can contain only the public key.</para>
            </summary>
            
            <param name="KeyStream">The byte array containing the key</param>
            
            <returns>An initialized MPKCPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>KeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.Exceptions.RLWEException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.Clone">
            <summary>
            Create a copy of this MPKCPublicKey instance
            </summary>
            
            <returns>MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.R2">
            <summary>
            Get: Returns the private key as a byte array
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.RLWE.RLWEPrivateKey.N">
            <summary>
            Get: Returns the number of coefficients
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20">
            <summary>
            <h3>Salsa20+: A parallelized Salsa20 stream cipher implementation.</h3>
            <para>A Salsa20 cipher extended to use up to 30 rounds of diffusion.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Salsa20())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/06/14" version="1.4.0.0">Added parallel processing</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">
            <summary>
            Stream Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key ot iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input and output arrays do not align or are too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Length of data to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of KeyParam. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes"/> property contains valid Key sizes. 
            IV must be 8 bytes in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv  is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Reset">
            <summary>
            Reset the primary internal counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Counter">
            <summary>
            Get the current counter value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt, ikm, or nonce is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus iv size, both are updated. 
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalSeedSizes">
            <summary>
            Get: Available Seed Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng">
            <summary>
            <h3>CTRPrng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new SP20Prng([SeedGenerators], [BufferSize], [SeedSize], [RoundsCount]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(VTDev.Libraries.CEXEngine.Crypto.SeedGenerators,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="SeedSize">The size of the seed to generate in bytes; can be 32 for a 128 bit key or 48 for a 256 bit key</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the seed is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the seed is an incorrect size; must be 32 or 48 bytes</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the rounds count is invalid; must be an even number between 10 and 30</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + iv of 16 bytes)</param>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the seed is null</exception>
            <exception cref="T:System.ArgumentException">Thrown if the seed is an incorrect size; must be 32 or 48 bytes</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the rounds count is invalid; must be an even number between 10 and 30</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
    </members>
</doc>
